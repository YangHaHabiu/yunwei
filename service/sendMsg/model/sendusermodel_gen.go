// Code generated by goctl. DO NOT EDIT!

package model

import (
	"context"
	"database/sql"
	"fmt"
	"github.com/zeromicro/go-zero/core/stores/builder"
	"github.com/zeromicro/go-zero/core/stores/sqlc"
	"github.com/zeromicro/go-zero/core/stores/sqlx"
	"github.com/zeromicro/go-zero/core/stringx"
	"strings"
)

var (
	sendUserFieldNames          = builder.RawFieldNames(&SendUser{})
	sendUserRows                = strings.Join(sendUserFieldNames, ",")
	sendUserRowsExpectAutoSet   = strings.Join(stringx.Remove(sendUserFieldNames, "`id`", "`create_time`", "`update_time`", "`create_at`", "`update_at`"), ",")
	sendUserRowsWithPlaceHolder = strings.Join(stringx.Remove(sendUserFieldNames, "`id`", "`create_time`", "`update_time`", "`create_at`", "`update_at`"), "=?,") + "=?"
)

type (
	sendUserModel interface {
		Insert(ctx context.Context, data *SendUser) (sql.Result, error)
		FindOne(ctx context.Context, id int64) (*SendUser, error)
		Update(ctx context.Context, data *SendUser) error
		Delete(ctx context.Context, id int64) error
		FindAllByNames(ctx context.Context, names, msgType string) (*[]SendUserNew, error)
		FindALLCallMsg(ctx context.Context, second int) (*[]CallMsgList, error)
		FindAllByGroups(ctx context.Context) (*[]GroupList, error)
	}

	defaultSendUserModel struct {
		conn  sqlx.SqlConn
		table string
	}

	SendUser struct {
		Id       int64  `db:"id"`
		EnName   string `db:"en_name"`  // 用户名
		CnName   string `db:"cn_name"`  // 用户名
		Email    string `db:"email"`    // 邮件
		Wechat   string `db:"wechat"`   // 微信
		Dingding string `db:"dingding"` // 钉钉
		Feishu   string `db:"feishu"`   // 飞书
	}
	SendUserNew struct {
		Id        int64  `db:"id"`
		EnName    string `db:"en_name"` // 用户名
		CnName    string `db:"cn_name"` // 用户名
		Result    string `db:"result"`
		GroupName string `db:"group_name"`
	}
	CallMsgList struct {
		ProjectEn sql.NullString `db:"project_en"`
		StartTime sql.NullInt64  `db:"start_time"`
		Tags      sql.NullString `db:"tags"`
		Counts    sql.NullInt64  `db:"counts"`
	}

	GroupList struct {
		Id        int64  `db:"id"`
		GroupName string `db:"group_name"`
	}
)

func newSendUserModel(conn sqlx.SqlConn) *defaultSendUserModel {
	return &defaultSendUserModel{
		conn:  conn,
		table: "`send_user`",
	}
}

func (m *defaultSendUserModel) Delete(ctx context.Context, id int64) error {
	query := fmt.Sprintf("delete from %s where `id` = ?", m.table)
	_, err := m.conn.ExecCtx(ctx, query, id)
	return err
}

func (m *defaultSendUserModel) FindOne(ctx context.Context, id int64) (*SendUser, error) {
	query := fmt.Sprintf("select %s from %s where `id` = ? limit 1", sendUserRows, m.table)
	var resp SendUser
	err := m.conn.QueryRowCtx(ctx, &resp, query, id)
	switch err {
	case nil:
		return &resp, nil
	case sqlc.ErrNotFound:
		return nil, ErrNotFound
	default:
		return nil, err
	}
}
func (m *defaultSendUserModel) FindAllByGroups(ctx context.Context) (*[]GroupList, error) {
	query := `select * from send_group`
	var resp []GroupList
	err := m.conn.QueryRowsCtx(ctx, &resp, query)
	switch err {
	case nil:
		return &resp, nil
	case sqlc.ErrNotFound:
		return nil, ErrNotFound
	default:
		return nil, err
	}
}

func (m *defaultSendUserModel) FindAllByNames(ctx context.Context, names, msgType string) (*[]SendUserNew, error) {
	query := `SELECT
B.id,
B.en_name,
B.cn_name,
B.group_name,
B.%s as result
FROM 
(
SELECT
	send_user.*,
	A.group_name 
FROM
	send_user
	LEFT JOIN ( SELECT 
	send_group.group_name,
	send_user_group.user_id 
	FROM send_group, send_user_group 
	WHERE 
	send_group.id = send_user_group.group_id
	) A 
	ON A.user_id = send_user.id
	) B
	WHERE 1=1
	AND ( en_name in ('%s') or group_name in ('%s') )`

	condition := strings.Join(strings.Split(names, ","), "','")
	query = fmt.Sprintf(query, msgType, condition, condition)
	var resp []SendUserNew
	err := m.conn.QueryRowsCtx(ctx, &resp, query)
	switch err {
	case nil:
		return &resp, nil
	case sqlc.ErrNotFound:
		return nil, ErrNotFound
	default:
		return nil, err
	}
}

func (m *defaultSendUserModel) Insert(ctx context.Context, data *SendUser) (sql.Result, error) {
	query := fmt.Sprintf("insert into %s (%s) values (?, ?, ?, ?, ?)", m.table, sendUserRowsExpectAutoSet)
	ret, err := m.conn.ExecCtx(ctx, query, data.EnName, data.CnName, data.Email, data.Wechat, data.Dingding, data.Feishu)
	return ret, err
}

func (m *defaultSendUserModel) Update(ctx context.Context, data *SendUser) error {
	query := fmt.Sprintf("update %s set %s where `id` = ?", m.table, sendUserRowsWithPlaceHolder)
	_, err := m.conn.ExecCtx(ctx, query, data.EnName, data.CnName, data.Email, data.Wechat, data.Dingding, data.Feishu, data.Id)
	return err
}

func (m *defaultSendUserModel) tableName() string {
	return m.table
}

//查询合服和维护计划合并信息信息
func (m *defaultSendUserModel) FindALLCallMsg(ctx context.Context, second int) (*[]CallMsgList, error) {
	query := `SELECT 
project_en,
start_time,
'maintain_plan' tags,
		'0' counts
FROM (
  SELECT
		project.project_en,
		maintain_plan.start_time
		
	FROM
		ywadmin_v3.maintain_plan maintain_plan
		INNER JOIN ywadmin_v3.project ON project.project_id = maintain_plan.project_id 
	WHERE
		maintain_plan.del_flag = 0 
		AND maintain_plan.start_time BETWEEN unix_timestamp(now()) AND unix_timestamp(now()) + %d
	) A
UNION
SELECT 
  project_en,
	IFNULL(start_time,'') start_time,
	'merge_plan' tags,
	count(*) counts
FROM (
SELECT
	project.project_en,
	merge_plan.start_time
	
FROM
	ywadmin_v3.merge_plan
	INNER JOIN ywadmin_v3.project ON project.project_id = merge_plan.project_id
WHERE
	merge_plan.del_flag = 0
	AND merge_plan.start_time BETWEEN unix_timestamp(now())- %d AND unix_timestamp(now())
	) A
GROUP BY project_en
`
	query = fmt.Sprintf(query, second, second)
	var resp []CallMsgList
	err := m.conn.QueryRowsCtx(ctx, &resp, query)
	switch err {
	case nil:
		return &resp, nil
	case sqlc.ErrNotFound:
		return nil, ErrNotFound
	default:
		return nil, err
	}
}
