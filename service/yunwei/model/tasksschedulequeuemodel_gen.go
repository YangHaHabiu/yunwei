// Code generated by goctl. DO NOT EDIT!

package model

import (
	"context"
	"encoding/json"
	"errors"

	"fmt"
	"strings"
	"ywadmin-v3/common/globalkey"
	"ywadmin-v3/common/xfilters"

	"github.com/zeromicro/go-zero/core/stores/builder"
	"github.com/zeromicro/go-zero/core/stores/sqlc"
	"github.com/zeromicro/go-zero/core/stores/sqlx"
	"github.com/zeromicro/go-zero/core/stringx"
	"google.golang.org/grpc/metadata"
)

var (
	tasksScheduleQueueFieldNames          = builder.RawFieldNames(&TasksScheduleQueue{})
	tasksScheduleQueueRows                = strings.Join(tasksScheduleQueueFieldNames, ",")
	tasksScheduleQueueRowsExpectAutoSet   = strings.Join(stringx.Remove(tasksScheduleQueueFieldNames, "`id`", "`create_time`", "`update_time`", "`create_at`", "`update_at`", "`del_flag`"), ",")
	tasksScheduleQueueRowsWithPlaceHolder = strings.Join(stringx.Remove(tasksScheduleQueueFieldNames, "`id`", "`create_time`", "`update_time`", "`create_at`", "`update_at`", "`del_flag`", "`schedule_create_by`"), "=?,") + "=?"
)

type (
	tasksScheduleQueueModel interface {
		Insert(ctx context.Context, data *TasksScheduleQueue, maps string) error
		FindOne(ctx context.Context, id int64) (*TasksScheduleQueue, error)
		Update(ctx context.Context, data *TasksScheduleQueue) error
		Delete(ctx context.Context, id int64) error
		FindPageListByPage(ctx context.Context, page, pageSize int64, filters ...interface{}) (*[]TasksScheduleQueueNew, error)
		DeleteSoft(ctx context.Context, id int64, maps string) error
		Count(ctx context.Context, filters ...interface{}) (int64, error)
		FindAll(ctx context.Context, filters ...interface{}) (*[]TasksScheduleQueueNew, error)
		BatchUpdateStatus(ctx context.Context, ids, logs string, status int, endTime int64) error
		FindAllViewInstallOpenList(ctx context.Context, filters ...interface{}) (*[]ViewInstallOpenList, error)
	}

	defaultTasksScheduleQueueModel struct {
		conn  sqlx.SqlConn
		table string
	}

	TasksScheduleQueue struct {
		Id                int64  `db:"id"`                  // 自增ID
		ScheduleTitle     string `db:"schedule_title"`      // 计划标题
		ScheduleStartTime int64  `db:"schedule_start_time"` // 计划开始时间
		ScheduleEndTime   int64  `db:"schedule_end_time"`   // 计划结束时间
		ScheduleStatus    string `db:"schedule_status"`     // 计划状态：1:待执行 2:进行中 3:成功 4:失败
		ScheduleType      string `db:"schedule_type"`       // 计划类型：1：开服计划 2：合服计划 3：其他计划
		ScheduleRangeIds  string `db:"schedule_range_ids"`  // 计划执行范围
		SchedulePid       int64  `db:"schedule_pid"`        // 计划执行pid
		ScheduleLogs      string `db:"schedule_logs"`       // 计划日志
		ScheduleRemark    string `db:"schedule_remark"`     // 计划备注
		ScheduleCreateBy  string `db:"schedule_create_by"`  //计划创建人
		DelFlag           int64  `db:"del_flag"`
	}

	TasksScheduleQueueNew struct {
		Id                   int64  `db:"id"`                  // 自增ID
		ScheduleTitle        string `db:"schedule_title"`      // 计划标题
		ScheduleStartTime    int64  `db:"schedule_start_time"` // 计划开始时间
		ScheduleEndTime      int64  `db:"schedule_end_time"`   // 计划结束时间
		ScheduleStatus       string `db:"schedule_status"`     // 计划状态：1:待执行 2:进行中 3:成功 4:失败
		ScheduleType         string `db:"schedule_type"`       // 计划类型：1：开服计划 2：合服计划 3：其他计划
		ScheduleRangeIds     string `db:"schedule_range_ids"`  // 计划执行范围
		SchedulePid          int64  `db:"schedule_pid"`        // 计划执行pid
		ScheduleLogs         string `db:"schedule_logs"`       // 计划日志
		ScheduleRemark       string `db:"schedule_remark"`     // 计划备注
		ScheduleCreateBy     string `db:"schedule_create_by"`  //计划创建人
		ScheduleTypeMaps     string `db:"schedule_type_maps"`
		ScheduleCreateByName string `db:"schedule_create_by_name"`
		DelFlag              int64  `db:"del_flag"`
	}
	ViewInstallOpenList struct {
		ViewInstallList    string `db:"view_install_list"`
		ViewOpenPlanAutoid int64  `db:"view_open_plan_autoid"`
	}
)

var scheduleCommonSql = `
SELECT %s FROM (
	SELECT
		A.*,
	  B.description schedule_type_maps,
		C.nick_name schedule_create_by_name
	FROM
		tasks_schedule_queue A
		INNER JOIN ( SELECT value, description FROM sys_dict WHERE pid != - 1 AND types = "schedule_types" ) B
		ON B.value = A.schedule_type
		INNER JOIN sys_user C
		ON A.schedule_create_by = C.id
	) D
	WHERE del_flag = 0
%s
%s
`

func newTasksScheduleQueueModel(conn sqlx.SqlConn) *defaultTasksScheduleQueueModel {
	return &defaultTasksScheduleQueueModel{
		conn:  conn,
		table: "`tasks_schedule_queue`",
	}
}

func (m *defaultTasksScheduleQueueModel) Delete(ctx context.Context, id int64) error {
	query := fmt.Sprintf("delete from %s where `id` = ?", m.table)
	_, err := m.conn.ExecCtx(ctx, query, id)
	return err
}

func (m *defaultTasksScheduleQueueModel) FindOne(ctx context.Context, id int64) (*TasksScheduleQueue, error) {
	query := fmt.Sprintf("select %s from %s where `id` = ? and del_flag =0 limit 1", tasksScheduleQueueRows, m.table)
	var resp TasksScheduleQueue
	err := m.conn.QueryRowCtx(ctx, &resp, query, id)
	switch err {
	case nil:
		return &resp, nil
	case sqlc.ErrNotFound:
		return nil, ErrNotFound
	default:
		return nil, err
	}
}

func (m *defaultTasksScheduleQueueModel) Insert(ctx context.Context, data *TasksScheduleQueue, maps string) error {
	var uid string
	if data.ScheduleCreateBy == "" {
		if md, ok := metadata.FromIncomingContext(ctx); ok {
			uid = md.Get("uid")[0]
		}
	} else {
		uid = data.ScheduleCreateBy
	}
	if uid == "" {
		return errors.New("获取到用户为空")
	}
	//反序列化maps
	var (
		t                       = make(map[string]string, 0)
		destTableCol, destTable string
	)
	err := json.Unmarshal([]byte(maps), &t)
	if err != nil {
		return err
	}
	destTable = t[data.ScheduleType]
	if data.ScheduleType == "1" {
		destTableCol = "install_status = 2"
	} else if data.ScheduleType == "2" {
		destTableCol = "merge_status = 2"
	}

	if destTableCol == "" || data.ScheduleRangeIds == "" {
		return errors.New("查询不到要对应计划表" + destTable + "状态字段")
	}
	if err := m.conn.Transact(func(session sqlx.Session) error {
		insertsql := fmt.Sprintf("insert into %s (%s) values (?, ?, ?, ?, ?, ?, ?, ?, ?,?)", m.table, tasksScheduleQueueRowsExpectAutoSet)

		stmt, err := session.Prepare(insertsql)
		if err != nil {
			return err
		}
		defer stmt.Close()
		// 写入计划队列表
		if _, err := stmt.ExecCtx(ctx, data.ScheduleTitle, data.ScheduleStartTime, data.ScheduleEndTime, data.ScheduleStatus, data.ScheduleType, data.ScheduleRangeIds, data.SchedulePid, data.ScheduleLogs, data.ScheduleRemark, uid); err != nil {
			return err
		}
		//修改对应的表的状态
		updatesql := fmt.Sprintf("update %s set %s where id in (%s)", destTable, destTableCol, data.ScheduleRangeIds)
		stmt, err = session.Prepare(updatesql)
		if err != nil {
			return err
		}
		if _, err := stmt.ExecCtx(ctx); err != nil {
			return err
		}

		return nil
	}); err != nil {
		return nil
	}

	return nil
}

func (m *defaultTasksScheduleQueueModel) BatchUpdateStatus(ctx context.Context, ids, logs string, status int, endTime int64) error {
	// var query string
	// args := fmt.Sprintf("schedule_status = %d", status)
	// if logs != "" {
	// 	args = args + fmt.Sprintf(`, schedule_logs = '%s'`, logs)
	// }
	// if endTime != 0 {
	// 	args = args + fmt.Sprintf(", schedule_end_time = %d", endTime)
	// }
	// query = fmt.Sprintf("update %s set %s where `id` in (%s)", m.table, args, ids)

	query := fmt.Sprintf("update %s set schedule_status = ?, schedule_logs = ?,schedule_end_time = ? where `id` in (%s)", m.table, ids)
	_, err := m.conn.ExecCtx(ctx, query, status, logs, endTime)
	return err
}

func (m *defaultTasksScheduleQueueModel) Update(ctx context.Context, data *TasksScheduleQueue) error {
	tsq, err := m.FindOne(ctx, data.Id)
	if err != nil {
		return err
	}
	if data.ScheduleTitle == "" {
		data.ScheduleTitle = tsq.ScheduleTitle
	}
	if data.ScheduleStartTime == 0 {
		data.ScheduleStartTime = tsq.ScheduleStartTime
	}
	if data.ScheduleEndTime == 0 {
		data.ScheduleEndTime = tsq.ScheduleEndTime
	}
	if data.SchedulePid == 0 {
		data.SchedulePid = tsq.SchedulePid
	}
	if data.ScheduleStatus == "" {
		data.ScheduleStatus = tsq.ScheduleStatus
	}
	if data.ScheduleType == "" {
		data.ScheduleType = tsq.ScheduleType
	}
	if data.ScheduleRangeIds == "" {
		data.ScheduleRangeIds = tsq.ScheduleRangeIds
	}
	if data.ScheduleLogs == "" {
		data.ScheduleLogs = tsq.ScheduleLogs
	}
	if data.ScheduleRemark == "" {
		data.ScheduleRemark = tsq.ScheduleRemark
	}

	query := fmt.Sprintf("update %s set %s where `id` = ?", m.table, tasksScheduleQueueRowsWithPlaceHolder)
	_, err = m.conn.ExecCtx(ctx, query, data.ScheduleTitle, data.ScheduleStartTime, data.ScheduleEndTime, data.ScheduleStatus, data.ScheduleType, data.ScheduleRangeIds, data.SchedulePid, data.ScheduleLogs, data.ScheduleRemark, data.Id)
	return err
}

func (m *defaultTasksScheduleQueueModel) tableName() string {
	return m.table
}

// 分页条件查询
func (m *defaultTasksScheduleQueueModel) FindPageListByPage(ctx context.Context, page, pageSize int64, filters ...interface{}) (*[]TasksScheduleQueueNew, error) {
	// 	query := `SELECT * from %s where del_flag = %d
	// %s
	// order by schedule_start_time desc
	// limit ? offset ?
	// `

	if page < 1 {
		page = 1
	}
	offset := (page - 1) * pageSize
	var condition string
	filter := xfilters.Xfilters(filters...)
	if len(filter) != 0 {
		condition = " and " + filter
	}
	query := fmt.Sprintf(scheduleCommonSql, "*", condition, "order by schedule_start_time desc limit ? offset ?")

	var resp []TasksScheduleQueueNew
	err := m.conn.QueryRowsCtx(ctx, &resp, query, pageSize, offset)
	switch err {
	case nil:
		return &resp, nil
	case sqlc.ErrNotFound:
		return nil, ErrNotFound
	default:
		return nil, err
	}
}

// 条件查询所有
func (m *defaultTasksScheduleQueueModel) FindAll(ctx context.Context, filters ...interface{}) (*[]TasksScheduleQueueNew, error) {
	//query := "select * from %s where del_flag = %d %s"
	var condition string
	filter := xfilters.Xfilters(filters...)
	if len(filter) != 0 {
		condition = " and " + filter
	}
	query := fmt.Sprintf(scheduleCommonSql, "*", condition, "")
	var resp []TasksScheduleQueueNew
	err := m.conn.QueryRowsCtx(ctx, &resp, query)
	switch err {
	case nil:
		return &resp, nil
	case sqlc.ErrNotFound:
		return nil, ErrNotFound
	default:
		return nil, err
	}
}

// 条件统计
func (m *defaultTasksScheduleQueueModel) Count(ctx context.Context, filters ...interface{}) (int64, error) {
	var condition string
	if len(xfilters.Xfilters(filters...)) != 0 {
		condition = " and " + xfilters.Xfilters(filters...)
	}
	query := fmt.Sprintf(scheduleCommonSql, "count(*)", condition, "")

	//query := fmt.Sprintf("select count(*) as count from %s where del_flag = %d %s", m.table, globalkey.DelStateNo, condition)
	var count int64
	err := m.conn.QueryRowCtx(ctx, &count, query)
	switch err {
	case nil:
		return count, nil
	case sqlc.ErrNotFound:
		return 0, ErrNotFound
	default:
		return 0, err
	}
}

// 软删除
func (m *defaultTasksScheduleQueueModel) DeleteSoft(ctx context.Context, id int64, maps string) error {
	data, err := m.FindOne(ctx, id)
	if err != nil {
		return err
	}

	//反序列化maps
	var (
		t                       = make(map[string]string, 0)
		destTableCol, destTable string
	)
	err = json.Unmarshal([]byte(maps), &t)
	if err != nil {
		return err
	}
	destTable = t[data.ScheduleType]
	if data.ScheduleType == "1" {
		destTableCol = "install_status = -1"
	} else if data.ScheduleType == "2" {
		destTableCol = "merge_status = -1"
	}
	if destTableCol == "" || data.ScheduleRangeIds == "" {
		return errors.New("查询不到要对应计划表" + destTable + "状态字段")
	}
	if err := m.conn.Transact(func(session sqlx.Session) error {
		updateTasksSql := fmt.Sprintf("update %s set `del_flag`=? where `id` = ?", m.table)
		stmt, err := session.Prepare(updateTasksSql)
		if err != nil {
			return err
		}
		defer stmt.Close()
		// 修改计划队列删除状态
		if _, err := stmt.ExecCtx(ctx, globalkey.DelStateYes, id); err != nil {
			return err
		}
		//修改对应的表的状态
		updatesql := fmt.Sprintf("update %s set %s where id in (%s)", destTable, destTableCol, data.ScheduleRangeIds)
		stmt, err = session.Prepare(updatesql)
		if err != nil {
			return err
		}
		if _, err := stmt.ExecCtx(ctx); err != nil {
			return err
		}
		return nil
	}); err != nil {
		return nil
	}

	return err
}

// 条件查询所有
func (m *defaultTasksScheduleQueueModel) FindAllViewInstallOpenList(ctx context.Context, filters ...interface{}) (*[]ViewInstallOpenList, error) {
	query := `select * from view_install_open_list where 1=1
	%s
	`
	var condition string
	filter := xfilters.Xfilters(filters...)
	if len(filter) != 0 {
		condition = " and " + filter
	}
	query = fmt.Sprintf(query, condition)
	var resp []ViewInstallOpenList
	err := m.conn.QueryRowsCtx(ctx, &resp, query)
	switch err {
	case nil:
		return &resp, nil
	case sqlc.ErrNotFound:
		return nil, ErrNotFound
	default:
		return nil, err
	}
}
